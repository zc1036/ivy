
(in-package :std.template)

(defun make-template-specializer-name (template-name)
  "Just appends a ! to the symbol name"
  (format nil "~a!") template-name)

(defmacro defun-template (template-name template-arguments function-arguments return-type &body body)
  (let ((explicit-template-specializer-name (make-template-specializer-name template-name))
        (args% (gensym)))
    `(progn
       (defun ,template-name (&rest arguments)
         (let ((,args% (list ,@arguments)))
           (instantiate-template-with-arguments (list ,@arguments))))

       (defmacro ,template-specializer-name ()
         ))))

(defparameter *template-expanders* `((defun . ,#'identity))
"*TEMPLATE-EXPANDERS* is an alist of (SYMBOL . FUNCTION) which associates
 templatable declaration definers with functions to perform the macro
 expansion. A template expander has the signature
   template-arguments template-body -> macroexpanded-definition")

(defmacro template (template-arguments &body body)
"Replaces one or more declarations (TEMPLATE-DEFINER ...) with the output of the
 appropriate expander function for each TEMPLATE-DEFINER (from *TEMPLATE-EXPANDERS*)"

  (loop for templated-declaration in body collect
       (progn
         (format t "~a~%" templated-declaration)
         (ematch templated-declaration
           ((cons (and sym (symbol)) rest)
            (let ((expander (assoc sym *template-expanders*)))
              (funcall (cdr expander) template-arguments rest)))))))

(defmacro define-template-expander (template-expander-name arguments &body body)
  `(push (cons ',template-expander-name (lambda ,arguments ,@body))))

(define-template-expander defun (template))

(defun-template *name* *template-lambda-list* *function-lambda-list* *return-type* *body*)

(defun-template hello ((A typename) (B int)) (A foo) int
  (return B))
